# Copyright 2021 The Private Cardinality Estimation Framework Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Uniformly random test point generator.

Each test point is generated by choosing the spend amount for each
publisher independently and uniformly at random from the interval
[0, s_i], where s_i is the maximum possible spend for publisher i.
"""

import numpy as np
from typing import Iterable
from typing import List
from typing import Callable
from wfa_planning_evaluation_framework.data_generators.data_set import DataSet
from wfa_planning_evaluation_framework.driver.test_point_generator import (
    TestPointGenerator,
)
from wfa_planning_evaluation_framework.driver.test_point_generator import (
    MINIMUM_NUMBER_OF_TEST_POINTS,
)


class UniformlyRandomTestPointGenerator(TestPointGenerator):
    """Generates a collection of test points for a given simulation."""

    def __init__(
        self,
        dataset: DataSet,
        rng: np.random.Generator,
        npoints_generator: Callable[[int], int] = lambda x: None,
        npoints: int = MINIMUM_NUMBER_OF_TEST_POINTS,
    ):
        """Returns a LatinHypercubeRandomTestPointGenerator.

        Args:
          dataset:  The DataSet for which test points are to be generated.
          rng:  A numpy Generator object that is used to seed the generation
            of random test points.
          npoints_generator: a function from the number of publishers to the
            number of test points. EÎ©xample is
            lambda npublishers: 2 ** npublishers
            If the function is an empty function, then obtain the number of test
            points directly from the next argument.
          npoints: Number of points to generate.
        """
        super().__init__(dataset)
        self._rng = rng
        if npoints_generator(1) is None:
            self._npoints = npoints
        else:
            self._npoints = npoints_generator(self._npublishers)

    def test_points(self) -> Iterable[List[float]]:
        """Returns a generator for generating a list of test points.

        Returns:
          An iterable of spend vectors representing locations where
          the true reach surface is to be compared to the modeled reach
          surface.
        """
        num_points = max(self._npoints, MINIMUM_NUMBER_OF_TEST_POINTS)
        for i in range(self._npoints):
            yield list(self._max_spends * self._rng.random(size=self._npublishers))
